/**
 * Tool Call Recovery Module
 *
 * Handles recovery from malformed tool calls generated by local models.
 * Implements multiple strategies:
 * 1. Text-based tool call extraction (parse JSON/XML from text)
 * 2. Parameter inference for missing required fields
 * 3. Retry prompt generation with error feedback
 */

import { log } from "../../logger.js";

export interface ExtractedToolCall {
  name: string;
  arguments: Record<string, any>;
  source: "structured" | "json_text" | "xml_text" | "inferred";
}

export interface ToolSchema {
  name: string;
  description?: string;
  input_schema?: {
    type: string;
    properties?: Record<string, any>;
    required?: string[];
  };
}

/**
 * Extract tool calls from text content
 * Many local models output tool calls as JSON in their text rather than using structured tool_calls
 */
export function extractToolCallsFromText(text: string): ExtractedToolCall[] {
  const extracted: ExtractedToolCall[] = [];

  // Pattern 0: Qwen-style function calls <function=NAME><parameter=PARAM>VALUE
  // Example: <function=SlashCommand><parameter=command>/ls -la
  const qwenPattern = /<function=([^>]+)>([\s\S]*?)(?=<function=|$)/gi;
  let match;
  while ((match = qwenPattern.exec(text)) !== null) {
    const funcName = match[1];
    const paramsText = match[2];
    const args: Record<string, any> = {};

    // Extract parameters: <parameter=name>value
    const paramPattern = /<parameter=([^>]+)>\s*([\s\S]*?)(?=<parameter=|<function=|$)/gi;
    let paramMatch;
    while ((paramMatch = paramPattern.exec(paramsText)) !== null) {
      const paramName = paramMatch[1];
      const paramValue = paramMatch[2].trim();
      args[paramName] = paramValue;
    }

    if (funcName) {
      extracted.push({
        name: funcName,
        arguments: args,
        source: "xml_text",
      });
      log(`[ToolRecovery] Extracted Qwen-style tool call: ${funcName}`);
    }
  }

  // Pattern 1: XML-style tool calls <tool_call>{"name": "...", "arguments": {...}}</tool_call>
  const xmlPattern = /<tool_call>\s*(\{[\s\S]*?\})\s*<\/tool_call>/gi;
  while ((match = xmlPattern.exec(text)) !== null) {
    try {
      const parsed = JSON.parse(match[1]);
      if (parsed.name) {
        extracted.push({
          name: parsed.name,
          arguments: parsed.arguments || parsed.input || parsed.parameters || {},
          source: "xml_text",
        });
      }
    } catch (e) {
      // Continue trying other patterns
    }
  }

  // Pattern 2: Function call format {"name": "tool_name", "arguments": {...}}
  const funcCallPattern = /\{\s*"name"\s*:\s*"([^"]+)"\s*,\s*"(?:arguments|input|parameters)"\s*:\s*(\{[\s\S]*?\})\s*\}/gi;
  while ((match = funcCallPattern.exec(text)) !== null) {
    try {
      const args = JSON.parse(match[2]);
      extracted.push({
        name: match[1],
        arguments: args,
        source: "json_text",
      });
    } catch (e) {
      // Continue
    }
  }

  // Pattern 3: Anthropic-style tool_use blocks in text
  const anthropicPattern = /\{\s*"type"\s*:\s*"tool_use"\s*,\s*"id"\s*:\s*"[^"]*"\s*,\s*"name"\s*:\s*"([^"]+)"\s*,\s*"input"\s*:\s*(\{[\s\S]*?\})\s*\}/gi;
  while ((match = anthropicPattern.exec(text)) !== null) {
    try {
      const args = JSON.parse(match[2]);
      extracted.push({
        name: match[1],
        arguments: args,
        source: "json_text",
      });
    } catch (e) {
      // Continue
    }
  }

  // Pattern 4: Simple JSON objects that look like tool calls (heuristic)
  // Look for JSON with common tool parameter names
  const jsonBlockPattern = /```(?:json)?\s*(\{[\s\S]*?\})\s*```/gi;
  while ((match = jsonBlockPattern.exec(text)) !== null) {
    try {
      const parsed = JSON.parse(match[1]);
      // Check if it looks like a tool call
      if (parsed.name && (parsed.arguments || parsed.input || parsed.parameters)) {
        extracted.push({
          name: parsed.name,
          arguments: parsed.arguments || parsed.input || parsed.parameters,
          source: "json_text",
        });
      }
    } catch (e) {
      // Continue
    }
  }

  return extracted;
}

/**
 * Infer missing parameters for known tools
 */
export function inferMissingParameters(
  toolName: string,
  args: Record<string, any>,
  missingParams: string[],
  context?: string
): Record<string, any> {
  const inferred = { ...args };

  // Task tool inference
  if (toolName === "Task") {
    if (missingParams.includes("subagent_type") && !inferred.subagent_type) {
      // Default to general-purpose if not specified
      inferred.subagent_type = "general-purpose";
      log(`[ToolRecovery] Inferred subagent_type: general-purpose`);
    }

    // Try to extract meaningful task description from context
    let extractedTask = "";
    if (context) {
      // Look for common patterns that indicate the model's intent
      const patterns = [
        /(?:I(?:'ll| will| need to| want to| am going to)|Let me|Going to)\s+([^.!?\n]+)/i,
        /(?:help you|assist with)\s+([^.!?\n]+)/i,
        /(?:explore|search|find|look for|investigate)\s+([^.!?\n]+)/i,
        /(?:implement|create|build|add|fix|update)\s+([^.!?\n]+)/i,
      ];
      for (const pattern of patterns) {
        const match = context.match(pattern);
        if (match && match[1] && match[1].length > 10) {
          extractedTask = match[1].trim();
          log(`[ToolRecovery] Extracted task from context: "${extractedTask.substring(0, 50)}..."`);
          break;
        }
      }
      // Fallback: use the last meaningful sentence as context
      if (!extractedTask && context.length > 20) {
        const sentences = context.split(/[.!?\n]+/).filter(s => s.trim().length > 15);
        if (sentences.length > 0) {
          extractedTask = sentences[sentences.length - 1].trim();
        }
      }
    }

    if (missingParams.includes("prompt") && !inferred.prompt) {
      // Try to use description, task content, or extracted context
      if (inferred.description && inferred.description !== "Execute task") {
        inferred.prompt = inferred.description;
      } else if (inferred.task) {
        inferred.prompt = inferred.task;
      } else if (extractedTask) {
        inferred.prompt = extractedTask;
      } else if (context && context.length > 20) {
        // Use the full context if nothing else works
        inferred.prompt = context.substring(0, 500).trim();
      }
      if (inferred.prompt) {
        log(`[ToolRecovery] Inferred prompt: "${inferred.prompt.substring(0, 50)}..."`);
      }
    }

    if (missingParams.includes("description") && !inferred.description) {
      // Generate description from prompt or extracted task
      if (inferred.prompt) {
        // Take first 50 chars of prompt as description
        inferred.description = inferred.prompt.substring(0, 50).replace(/\s+/g, " ").trim();
        if (inferred.description.length < inferred.prompt.length) {
          inferred.description += "...";
        }
      } else if (extractedTask) {
        inferred.description = extractedTask.substring(0, 50).trim();
      } else {
        inferred.description = "Execute task";
      }
      log(`[ToolRecovery] Inferred description: ${inferred.description}`);
    }
  }

  // Bash tool inference
  if (toolName === "Bash") {
    if (missingParams.includes("command") && !inferred.command) {
      // Check for common alternative parameter names
      inferred.command = inferred.cmd || inferred.shell || inferred.script || "";
    }
    if (missingParams.includes("description") && !inferred.description) {
      if (inferred.command) {
        // Generate description from command
        const cmd = inferred.command.split(" ")[0];
        inferred.description = `Run ${cmd} command`;
      }
    }
  }

  // Read tool inference
  if (toolName === "Read") {
    if (missingParams.includes("file_path") && !inferred.file_path) {
      inferred.file_path = inferred.path || inferred.file || inferred.filename || "";
    }
  }

  // Write tool inference
  if (toolName === "Write") {
    if (missingParams.includes("file_path") && !inferred.file_path) {
      inferred.file_path = inferred.path || inferred.file || inferred.filename || "";
    }
    if (missingParams.includes("content") && !inferred.content) {
      inferred.content = inferred.text || inferred.data || inferred.body || "";
    }
  }

  // Grep tool inference
  if (toolName === "Grep") {
    if (missingParams.includes("pattern") && !inferred.pattern) {
      inferred.pattern = inferred.query || inferred.search || inferred.regex || "";
    }
  }

  // Glob tool inference
  if (toolName === "Glob") {
    if (missingParams.includes("pattern") && !inferred.pattern) {
      inferred.pattern = inferred.glob || inferred.path || inferred.search || "**/*";
    }
  }

  return inferred;
}

/**
 * Generate a retry prompt with error feedback
 */
export function generateRetryPrompt(
  toolName: string,
  missingParams: string[],
  providedArgs: Record<string, any>,
  toolSchema?: ToolSchema
): string {
  let prompt = `Your previous tool call to "${toolName}" was incomplete. `;
  prompt += `Missing required parameters: ${missingParams.join(", ")}.\n\n`;

  if (toolSchema?.input_schema?.properties) {
    prompt += `The ${toolName} tool requires:\n`;
    for (const param of missingParams) {
      const propSchema = toolSchema.input_schema.properties[param];
      if (propSchema) {
        prompt += `- ${param}: ${propSchema.description || propSchema.type || "required"}\n`;
      } else {
        prompt += `- ${param}: required\n`;
      }
    }
    prompt += "\n";
  }

  prompt += `You provided: ${JSON.stringify(providedArgs, null, 2)}\n\n`;
  prompt += `Please try again with ALL required parameters included.`;

  return prompt;
}

/**
 * Check if a tool call can be repaired
 */
export function canRepairToolCall(
  toolName: string,
  args: Record<string, any>,
  missingParams: string[]
): boolean {
  // Check if we have enough context to infer the missing params
  const inferred = inferMissingParameters(toolName, args, missingParams);

  // Verify all missing params are now present
  for (const param of missingParams) {
    if (!inferred[param] || inferred[param] === "") {
      return false;
    }
  }

  return true;
}

/**
 * Get tool calling guidance to add to system prompt for local models
 */
export function getToolCallingGuidance(): string {
  return `
IMPORTANT TOOL CALLING INSTRUCTIONS:
When calling tools/functions, you MUST include ALL required parameters. Incomplete tool calls will fail.

For the Task tool, you MUST always provide:
- description: A short (3-5 word) description of the task
- prompt: The detailed task instructions
- subagent_type: The type of agent (e.g., "general-purpose", "Explore", "Plan")

For the Bash tool, you MUST always provide:
- command: The shell command to execute
- description: A brief description of what the command does

For file tools (Read, Write, Edit), always provide the full file_path.

Format your tool calls as valid JSON with all required fields populated.
`;
}

/**
 * Validate and potentially repair a tool call
 * Returns the repaired arguments if successful, null if repair failed
 */
export function validateAndRepairToolCall(
  toolName: string,
  argsStr: string,
  toolSchemas: ToolSchema[],
  textContent?: string
): {
  valid: boolean;
  args: Record<string, any>;
  repaired: boolean;
  missingParams: string[];
} {
  const schema = toolSchemas.find(t => t.name === toolName);
  if (!schema?.input_schema) {
    return { valid: true, args: {}, repaired: false, missingParams: [] };
  }

  let parsedArgs: Record<string, any> = {};
  try {
    parsedArgs = argsStr ? JSON.parse(argsStr) : {};
  } catch (e) {
    // Try to extract from text if structured parsing failed
    if (textContent) {
      const extracted = extractToolCallsFromText(textContent);
      const matching = extracted.find(tc => tc.name === toolName);
      if (matching) {
        parsedArgs = matching.arguments;
        log(`[ToolRecovery] Extracted tool args from text for ${toolName}`);
      }
    }
  }

  const required = schema.input_schema.required || [];
  const missingParams = required.filter(param =>
    parsedArgs[param] === undefined || parsedArgs[param] === null || parsedArgs[param] === ""
  );

  if (missingParams.length === 0) {
    return { valid: true, args: parsedArgs, repaired: false, missingParams: [] };
  }

  // Try to infer missing parameters
  const repairedArgs = inferMissingParameters(toolName, parsedArgs, missingParams, textContent);

  // Check if repair was successful
  const stillMissing = required.filter(param =>
    repairedArgs[param] === undefined || repairedArgs[param] === null || repairedArgs[param] === ""
  );

  if (stillMissing.length === 0) {
    log(`[ToolRecovery] Successfully repaired tool call ${toolName}`);
    return { valid: true, args: repairedArgs, repaired: true, missingParams: [] };
  }

  return { valid: false, args: repairedArgs, repaired: false, missingParams: stillMissing };
}
